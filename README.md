# Morse Code Generator using MATLAB

This Project aims towards generating Morse Code of Letters, words and Sentences with audio <br><br> 
Text to speech (using .NET framework) is included that will Translate those morse codes in the form of (dot, dashes, next letter, next word) <br><br>
A Graph (showing codes in the form of lines) dot is represented in the form of thin lines and Dashes in the form of Thick lines and spaces to differentiate 
between letters and words 

<hr>

## Logic
The binary tree defining Morse code. A branch to the left signifies a dot in the code and a branch to the  right is a dash. In addition to the root node, there are 26 nodes containing the capital letters of the English alphabet.

This is a binary tree, and for our purposes, it is the definition of Morse code. In contrast to nature, computer scientists put the root of a tree on top. Starting at this root, or any other node, and moving left along a link signifies a dot, while moving right is a dash. 

<p>
  <img src="https://github.com/Gaurav-Van/Morse_Code_Generator/assets/50765800/75ccf871-7b09-4b3e-b98b-5c8e6adf7f5d" height=200 width="450" />
  <img src="https://github.com/Gaurav-Van/Morse_Code_Generator/assets/50765800/32e4bceb-f5ef-4ae0-88ed-09bca7cd6753" height=200 width="450" /> 
</p>

### Cell Arrays
Binary trees are best implemented in Matlab by cell arrays, which are arrays whose elements are themselves other Matlab objects, including other arrays. Cell arrays have two kinds of indexing operations. Curly braces, { and }, are used for construction and for accessing individual cells. Conventional smooth parentheses, ( and ), are used for accessing subarrays. For example, 
```
C = {’A’,’rolling’,’stone’,’gathers’,’momentum’,’.’}
```
produces a cell array that contains six strings of different lengths. This example is displayed as 
```
C = ’A’ ’rolling’ ’stone’ ’gathers’ ’momentum’ ’.’ 
```
The third element, denoted with curly braces by C{3}, is the string ’stone’. The third subarray, denoted with parentheses by C(3), is another cell array containing a single element, the string ’stone’. Now go back and read those last two sentences a few more times. The subtle distinction between them is both the key to the power of cell arrays and the source of pervasive confusion. 

### Implementing Morse tree with the help of cell arrays 
The binary tree defining Morse code is a cell array whose contents are characters and other cell arrays. Each cell represents a node in the tree. A cell, N, has three elements, The first element, N{1}, is a string with a single capital letter, X, designating the node. The second element, N{2}, is another cell array, the dot branch. The third element, N{3}, is the dash branch. There are a couple of exceptional cases. The root node does not have an associated letter, so its first element is an empty string. The U and R nodes, and the leaf nodes, have one or two empty cell arrays for branches.
```
M = {’’ e t}; 
```
M{2} refers to left child and M{3} refers to right child and as this is a cell array ‘e’ and ‘t’ itself are cell arrays containing further nodes for example,
```
e = {’E’ i a};
```
this futher contains connection to children nodes . Here M = M{2} and then M{3} will direct us to right children of e 
```
 t = {’T’ n m}; 
```
this futher contains connection to children nodes . Here M = M{3} and then M{3} will direct us to right children of t

In this way binary tree or here in this case morse tree is implemented and morse code is generated by decoding and encoding which is achieved by traversing the tree either in DFS (Depth first search) or BFS (Breadth first search) method<br><br>
Depth first search visits each branch as soon as it sees it. When it has visited both branches at a node, it backs up to the first node that has an available branch or it traverses from LEFT to RIGHT<br><br>
Breadth first search takes one step along each branch at a node before it continues. The result is a top to bottom search, much like reading English language text.

### Decoding
Decoding is the process of translating dots and dashes into text. Encoding is the reverse. With our binary tree, decoding is easier than encoding because the dots and dashes directly determine which links to follow 
-	Like if we encounter ‘ .’ , now according to the logic of the morse tree we will move to the left of the tree ( M{2} ) 
-	If we encounter ‘-‘,  now according to the logic of the morse tree we will move to the right of the tree ( M{3} ) and if there are no dot and dashes we will return ‘*’. 
-	if dd(k) == ’.’ 
     M = M{2}; 
-	elseif dd(k) == ’-’
      M = M{3};

### Encoding
Encoding is a little more work because we have to search the tree until we find the desired letter. Here we employs depth first search to encode one character. A stack of dots and dashes is built up during the search. Again, an asterisk is returned if the input character is not in the tree.
-	During the search if we encounters the letter , we returns it. Otherwise A stack of dot and dashes is created respective of search [left search -  dot is stacked, right search – dash is stacked] 
-	S = {N{2} N{3} S{:}}; 
-	D = {[dd ’.’] [dd ’-’] D{:}};


